<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微信小程序开发--【初体验】(一)</title>
      <link href="/2019/02/22/wei-xin-xiao-cheng-xu/wei-xin-xiao-cheng-xu-kai-fa-chu-ti-yan-yi/"/>
      <url>/2019/02/22/wei-xin-xiao-cheng-xu/wei-xin-xiao-cheng-xu-kai-fa-chu-ti-yan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="第一步–注册账号"><a href="#第一步–注册账号" class="headerlink" title="第一步–注册账号"></a>第一步–注册账号</h1><p><a href="https://mp.weixin.qq.com/cgi-bin/registermidpage?action=index&amp;lang=zh_CN&amp;token=" target="_blank" rel="noopener">https://mp.weixin.qq.com/cgi-bin/registermidpage?action=index&amp;lang=zh_CN&amp;token=</a></p><p><img src="https://img-blog.csdn.net/2018102421535183?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="80%" alt></p><p>切记：<br>订阅号、服务号、小程序、企业微信，以上四种功能每个邮箱仅能申请一种帐号。</p><h1 id="第二步–登录"><a href="#第二步–登录" class="headerlink" title="第二步–登录"></a>第二步–登录</h1><p>登录后我们看到的界面如图所示：</p><p><img src="https://img-blog.csdn.net/2018102421544251?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="80%" alt></p><p>我们看到东西特别多，我们一步一步来</p><h1 id="第三步–完善小程序信息"><a href="#第三步–完善小程序信息" class="headerlink" title="第三步–完善小程序信息"></a>第三步–完善小程序信息</h1><p><img src="https://img-blog.csdn.net/20181024215456302?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="80%" alt></p><p>主要是：小程序名称，小程序头像，介绍</p><p>这里的内容我们可以先随便写写，后续是可以修改的。</p><h1 id="第四步–添加开发者"><a href="#第四步–添加开发者" class="headerlink" title="第四步–添加开发者"></a>第四步–添加开发者</h1><p><img src="https://img-blog.csdn.net/20181024215510231?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="80%" alt></p><p>我们注册的账号是管理员权限，拥有所有权限，我们可以去添加成员并给成员分配权限。</p><h1 id="第五步–开发者工具"><a href="#第五步–开发者工具" class="headerlink" title="第五步–开发者工具"></a>第五步–开发者工具</h1><p>在设置中我们需要去申请开发者工具</p><p><img src="https://img-blog.csdn.net/20181024215519895?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="80%" alt></p><p>我们先去申请腾讯云,TGIT和地图想申请也可以</p><p><img src="https://img-blog.csdn.net/20181024215527260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="80%" alt></p><blockquote><p>功能介绍</p><ul><li>腾讯云为开发者提供免费的开发环境和生产环境，更加方便、快速、可靠的构建您的小程序</li><li>点击左侧开通按钮，完成帐号授权，即可使用官方开发工具上传代码至开发环境进行调试</li><li>生产环境的开通，请前往腾讯云控制台进行相关操作</li><li>开发环境和生产环境支持nodejs及PHP语言</li><li>详细的开发环境和生产环境介绍，请查看相关文档</li></ul></blockquote><p>开通成功后我们可以看到如图所示的步骤，我们只需要按照步骤一步一步进行就可以成功开通。</p><p><img src="https://img-blog.csdn.net/20181024215535876?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="80%" alt></p><p>附录：<br>微信开发工具<br><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></p><p>微信DEMO：<br>微信搜索“小程序示例” 如下图我们可以先了解一下官方组件。</p><p><img src="https://img-blog.csdn.net/20181024225441469?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="80%" alt></p><p><img src="https://img-blog.csdn.net/20181024225528884?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="80%" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章作为小程序开发的初篇，介绍了需要的账号，权限以及需要开通的服务。<br>下一篇将介绍我们第一个小程序。</p><p><strong>～～号外～～福利～～号外～～</strong><br><strong>程序员的福音：</strong> “老曾筋骨祛痛贴”，百年祖传配方，专治<em>腰间盘</em>、<em>肩周</em>、<em>颈椎</em>、<em>坐骨神经</em>、<em>腰腿疼痛</em>等，博主亲测效果非常棒，因长期久坐写代码，坐姿不规范导致脖子疼，腰椎疼，用过之后疼痛逐渐缓解，现在已无任何疼痛，用过后让你写代码一身轻松，so easy，妈妈再也不用担心我们写代码了。<br>购买链接： <a href="https://k.weidian.com/tja7GYzB" target="_blank" rel="noopener">https://k.weidian.com/tja7GYzB</a><br><img src="https://img-blog.csdnimg.cn/20190213230334214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==" width="40%" alt></p><p><strong>扫码下方二维码，关注公众号“伟大程序猿的诞生“，回复“膏药”领取优惠券</strong><br><strong>扫码关注公众号“伟大程序猿的诞生“，更多干货新鲜文章等着你～</strong><br><img src="http://img.blog.csdn.net/20171218195006434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2l0aHViXzMzMzA0MjYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="40%" alt><br><strong>公众号回复“资料获取”，获取更多干货哦～</strong><br><strong>公众号回复“膏药”，领取优惠券哦～</strong></p><p><strong><em>有问题添加本人</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android TV开发总结【适配】</title>
      <link href="/2019/02/21/androidtv/androidtv-kai-fa-zong-jie-gua-pei/"/>
      <url>/2019/02/21/androidtv/androidtv-kai-fa-zong-jie-gua-pei/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android 的屏幕适配是指适配不同机顶盒 UI 框架层输出的分辨率和 dpi，而不是适配不同分辨率的电视机（电视机的适配交由机顶盒本身完成，和各个应用无关）</p><p>之前的文章有介绍过适配相关的问题在和dimens插件，可以前往了解：</p><p><a href="https://blog.csdn.net/github_33304260/article/details/76383298" target="_blank" rel="noopener">Android完美适配dimens.xml脚本</a></p><p><a href="https://blog.csdn.net/github_33304260/article/details/76805304" target="_blank" rel="noopener">打造AS酷炫dimens适配插件</a></p><h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="1、什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？"><a href="#1、什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？" class="headerlink" title="1、什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？"></a>1、什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？</h2><blockquote><ul><li>屏幕尺寸是指屏幕对角线的长度。单位是英寸，1英寸=2.54厘米；</li><li>屏幕分辨率是指在横纵向上的像素点数，单位是px，1px=1像素点，一般是纵向像素横向像素，如1280×720；</li><li>屏幕像素密度是指每英寸上的像素点数，单位是dpi，即“dot per inch”的缩写，像素密度和屏幕尺寸和屏幕分辨率有关;</li></ul></blockquote><p>像素密度公式：<br><img src="https://img-blog.csdn.net/20170730155613580?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2l0aHViXzMzMzA0MjYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="50%" alt></p><p>例如：</p><table><thead><tr><th align="center">600<em>1024的8寸屏幕</em></th><th align="center">7201280的8寸屏幕</th></tr></thead><tbody><tr><td align="center"><img src="https://img-blog.csdn.net/20170730155942055?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2l0aHViXzMzMzA0MjYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt title></td><td align="center"><img src="https://img-blog.csdn.net/20170730155954301?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2l0aHViXzMzMzA0MjYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt title></td></tr></tbody></table><h2 id="2、什么是dp、dip、dpi、sp、px？之间的关系是什么？"><a href="#2、什么是dp、dip、dpi、sp、px？之间的关系是什么？" class="headerlink" title="2、什么是dp、dip、dpi、sp、px？之间的关系是什么？"></a>2、什么是dp、dip、dpi、sp、px？之间的关系是什么？</h2><blockquote><ul><li>dip：Density Independent Pixels（密度无关像素）的缩写。以160dpi为基准，1dp=1px</li><li>dp：同dip</li><li>dpi：屏幕像素密度的单位，“dot per inch”的缩写</li><li>px：像素，物理上的绝对单位</li><li>sp：Scale-Independent Pixels的缩写，可以根据文字大小首选项自动进行缩放。Google推荐我们使用12sp以上的大小，通常可以使用12sp，14sp，18sp，22sp，最好不要使用奇数和小数。</li></ul></blockquote><p>如图：<br><img src="http://img.mukewang.com/564d3ae300018ec605780445.png" width="50%" alt></p><h2 id="3、什么是mdpi、hdpi、xdpi、xxdpi、xxxdpi？如何计算和区分？"><a href="#3、什么是mdpi、hdpi、xdpi、xxdpi、xxxdpi？如何计算和区分？" class="headerlink" title="3、什么是mdpi、hdpi、xdpi、xxdpi、xxxdpi？如何计算和区分？"></a>3、什么是mdpi、hdpi、xdpi、xxdpi、xxxdpi？如何计算和区分？</h2><p>在Google官方开发文档中，说明了 mdpi：hdpi：xhdpi：xxhdpi：xxxhdpi=2：3：4：6：8 的尺寸比例进行缩放。例如，一个图标的大小为48×48dp，表示在mdpi上，实际大小为48×48px，在hdpi像素密度上，实际尺寸为mdpi上的1.5倍，即72×72px，以此类推。</p><h1 id="适配前准备工作"><a href="#适配前准备工作" class="headerlink" title="适配前准备工作"></a>适配前准备工作</h1><h2 id="1、获取设备分辨率和dpi"><a href="#1、获取设备分辨率和dpi" class="headerlink" title="1、获取设备分辨率和dpi"></a>1、获取设备分辨率和dpi</h2><p>可以通过以下代码获取机顶盒UI框架层实际输出的分辨率 (width * height)，以及输出的像素密度和像素密度比值</p><pre><code>DisplayMetrics dm = new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(dm);//display = getWindowManager().getDefaultDisplay();display.getMetrics(dm)（把屏幕尺寸信息赋值给DisplayMetrics dm）;int width = dm.widthPixels;int height = dm.heightPixels;// 屏幕密度（1.0 / 1.5 / 2.0）float density = dm.density;// 屏幕密度DPI（160 / 240 / 320）int densityDpi = dm.densityDpi;Logger.e(&quot;当前设备的分辨率宽=（&quot; + width + &quot;*  高度=&quot; + height + &quot;）  densityDpi =&quot; + densityDpi + &quot;  density=&quot; + density);</code></pre><p>输出：</p><pre><code>当前设备的分辨 （率宽=1920*高度=1080）  densityDpi =160  density=1.0</code></pre><h2 id="2、与UI沟通如何出图？"><a href="#2、与UI沟通如何出图？" class="headerlink" title="2、与UI沟通如何出图？"></a>2、与UI沟通如何出图？</h2><blockquote><ul><li>切图应该放哪个 drawable 文件夹下，切多大？</li><li>UI 应该以什么标准出图？</li><li>UI 出的标注图 px 和 dp之间如何转换？</li></ul></blockquote><p>举个例子：<br>某款盒子通过上述代码获得分辨率为1920<em>1080 ，DPI为160dpi，盒子连接的是4K的电视分辨率为3840</em>2160：</p><blockquote><ul><li>通过160dpi，根据上表可以得知图片放在<code>drawable-mdpi</code>文件夹下</li><li>在只考虑当前设备的情况下，UI应该以盒子的像素1920<em>1080出图因为，app 在机顶盒上实际输出的像素就只有1920</em>1080像素，而在4K电视上4K显示效果是机顶盒将系统UI框架的 1920<em>1080 像素的输出优化放大道 3840 </em> 2160 像素</li><li>在160dpi情况下，px与dp是1倍的关系，所以1px = 1dp</li></ul></blockquote><h1 id="适配规则"><a href="#适配规则" class="headerlink" title="适配规则"></a>适配规则</h1><p>了解了基本知识和出图标准接下来我们来看一下如何适配：</p><p>如果此时我们又有一台设备分辨率为1920<em>1080 ，DPI为213dpi，盒子连接的是4K的电视分辨率为3840</em>2160：</p><p>我们可以计算一下倍数关系 213/160 = 1.33 ，我们发现并不是上面表格中提供的参数，是个非常奇葩的数字，此时我们计算一下宽度的dp值：1080/1.33=812，所以我们图片和资源文件可以放在<code>values-sw812dp</code>和<code>drawable-sw812dp</code>下面。<br>此时dimens文件中的数值也需要转换，两个相差1.33倍，那么 {<strong><em>现在的dimens数值=(原来的dimens数值 /1.33)</em></strong>}<br>建议使用<a href="https://blog.csdn.net/github_33304260/article/details/76805304" target="_blank" rel="noopener">打造AS酷炫dimens适配插件</a> 本人的插件，方便做dimens适配哦。</p><p>这里只是教大家了一种机型的适配，实际开发中可能会遇到更多奇葩的机型，大家也可以直接使用<code>values-1920x1080</code>或者<code>values-1920x1080-mdpi</code>或者<code>values-sw812dp-mdpi</code>这种组合也可以，道理都是一样的。</p><p>详细过程可以参考官方教程<a href="https://developer.android.google.cn/guide/practices/screens_support" target="_blank" rel="noopener">屏幕兼容性概览</a></p><table><tr><th>屏幕配置</th><th>限定符值</th><th>说明</th></tr><tr><td>smallestWidth</td><td><code>sw&lt;N&gt;dp</code><br><br>示例：<br><code>sw600dp</code><br><code>sw720dp</code><br></td><td><p>屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。具体来说，设备的 smallestWidth是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用UI 的可用宽度至少为<code>&lt;N&gt;</code>dp。</p><p>例如，如果布局要求屏幕区域的最小尺寸始终至少为600 dp，则可使用此限定符创建布局资源 <code>res/layout-sw600dp/</code>。仅当可用屏幕的最小尺寸至少为600dp 时，系统才会使用这些资源，而不考虑600dp 所代表的边是用户所认为的高度还是宽度。smallestWidth 是设备的固定屏幕尺寸特性；<strong>设备的 smallestWidth 不会随屏幕方向的变化而改变</strong>。</p><p>设备的 smallestWidth 将屏幕装饰元素和系统 UI 考虑在内。例如，如果设备的屏幕上有一些永久性 UI 元素占据沿 smallestWidth 轴的空间，则系统会声明 smallestWidth 小于实际屏幕尺寸，因为这些屏幕像素不适用于您的 UI。</p><p>这可替代通用化的屏幕尺寸限定符（小、正常、大、超大），可让您为 UI 可用的有效尺寸定义不连续的数值。使用 smallestWidth 定义一般屏幕尺寸很有用，因为宽度通常是设计布局时的驱动因素。UI 经常会垂直滚动，但对其水平需要的最小空间具有非常硬性的限制。可用的宽度也是确定是否对手机使用单窗格布局或是对平板电脑使用多窗格布局的关键因素。因此，您可能最关注每部设备上的最小可能宽度。</p></td></tr><tr><td>可用屏幕宽度</td><td><code>w&lt;N&gt;dp</code><br><br>示例：<br><code>w720dp</code><br><code>w1024dp</code><br></td><td><p>指定资源应该使用的最小可用宽度（dp 单位）&mdash; 由 <code>&lt;N&gt;</code> 值定义。当屏幕的方向在横屏与竖屏之间切换时，系统对应的宽度值将会变化，以反映 UI 可用的当前实际宽度。</p><p>这对于确定是否使用多窗格布局往往很有用，因为即使是在平板电脑设备上，您也通常不希望竖屏像横屏一样使用多窗格布局。因此，您可以使用此功能指定布局需要的最小宽度，而无需同时使用屏幕尺寸和方向限定符。</p></td></tr><tr><td>可用屏幕高度</td><td><code>h&lt;N&gt;dp</code><br><br>示例：<br><code>h720dp</code><br><code>h1024dp</code><br>等等</td><td><p>指定资源应该使用的最小屏幕高度（dp 单位）&mdash; 由 <code>&lt;N&gt;</code> 值定义。当屏幕的方向在横屏与竖屏之间切换时，系统对应的高度值将会变化，以反映 UI 可用的当前实际高度。</p><p>使用此方式定义布局需要的高度很有用，它与使用 <code>w&lt;N&gt;dp</code> 定义所需宽度的方式相同，无需同时使用屏幕尺寸和方向限定符。但大多数应用不需要此限定符，考虑到 UI 经常垂直滚动，因此高度更弹性，而宽度更刚性。</p></td></tr></table><p><strong>～～号外～～福利～～号外～～</strong><br><strong>程序员的福音：</strong> “老曾筋骨祛痛贴”，百年祖传配方，专治<em>腰间盘</em>、<em>肩周</em>、<em>颈椎</em>、<em>坐骨神经</em>、<em>腰腿疼痛</em>等，博主亲测效果非常棒，因长期久坐写代码，坐姿不规范导致脖子疼，腰椎疼，用过之后疼痛逐渐缓解，现在已无任何疼痛，用过后让你写代码一身轻松，so easy，妈妈再也不用担心我们写代码了。<br>购买链接： <a href="https://k.weidian.com/tja7GYzB" target="_blank" rel="noopener">https://k.weidian.com/tja7GYzB</a><br><img src="https://img-blog.csdnimg.cn/20190213230334214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==" width="40%" alt></p><p><strong>扫码下方二维码，关注公众号“伟大程序猿的诞生“，回复“膏药”领取优惠券</strong><br><strong>扫码关注公众号“伟大程序猿的诞生“，更多干货新鲜文章等着你～</strong><br><img src="http://img.blog.csdn.net/20171218195006434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2l0aHViXzMzMzA0MjYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="40%" alt><br><strong>公众号回复“资料获取”，获取更多干货哦～</strong><br><strong>公众号回复“膏药”，领取优惠券哦～</strong></p><p><strong><em>有问题添加本人</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> AndroidTV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AndroidTV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发--【APP(Object)函数介绍】(三)</title>
      <link href="/2019/02/21/wei-xin-xiao-cheng-xu/wei-xin-xiao-cheng-xu-kai-fa-app-object-han-shu-jie-shao-san/"/>
      <url>/2019/02/21/wei-xin-xiao-cheng-xu/wei-xin-xiao-cheng-xu-kai-fa-app-object-han-shu-jie-shao-san/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是APP-Object"><a href="#什么是APP-Object" class="headerlink" title="什么是APP(Object)"></a>什么是APP(Object)</h1><p><code>App()`</code> 函数用来注册一个小程序。接受一个 Object 参数，其指定小程序的生命周期回调等。</p><p>所以也被称为<strong>注册程序</strong></p><p><code>App()</code> 必须在 <code>app.js</code> 中调用，必须调用且只能调用<strong>一次</strong>。不然会出现无法预期的后果。</p><p>这个有点像安卓开发中的<code>Application</code>。只有一个而且调用一次。</p><h1 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h1><table><thead><tr><th>属性</th><th>类型</th><th>描述</th><th>触发时机</th></tr></thead><tbody><tr><td><a href="#onlaunchobject">onLaunch</a></td><td>Function</td><td>生命周期回调—监听小程序初始化</td><td>小程序初始化完成时（全局只触发一次）</td></tr><tr><td><a href="#onshowobject">onShow</a></td><td>Function</td><td>生命周期回调—监听小程序显示</td><td>小程序启动，或从后台进入前台显示时</td></tr><tr><td><a href="#onhide">onHide</a></td><td>Function</td><td>生命周期回调—监听小程序隐藏</td><td>小程序从前台进入后台时</td></tr><tr><td><a href="#onerrorstring-error">onError</a></td><td>Function</td><td>错误监听函数</td><td>小程序发生脚本错误，或者 api 调用失败时触发，会带上错误信息</td></tr><tr><td><a href="#onpagenotfoundobject">onPageNotFound</a></td><td>Function</td><td>页面不存在监听函数</td><td>小程序要打开的页面不存在时触发，会带上页面信息回调该函数</td></tr><tr><td>其他</td><td>Any</td><td>开发者可以添加任意的函数或数据到 <code>Object</code> 参数中，用 <code>this</code> 可以访问</td><td></td></tr></tbody></table><p><strong>前台</strong>、<strong>后台</strong>定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</p><h2 id="onLaunch-Object"><a href="#onLaunch-Object" class="headerlink" title="onLaunch(Object)"></a>onLaunch(Object)</h2><p>小程序初始化完成时触发，全局只触发一次。参数也可以使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/wx.getLaunchOptionsSync.html" target="_blank" rel="noopener">wx.getLaunchOptionsSync</a> 获取。</p><p><strong>参数说明：</strong></p><p>与 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/wx.getLaunchOptionsSync.html" target="_blank" rel="noopener">wx.getLaunchOptionsSync</a> 一致</p><h2 id="onShow-Object"><a href="#onShow-Object" class="headerlink" title="onShow(Object)"></a>onShow(Object)</h2><p>小程序启动，或从后台进入前台显示时触发。也可以使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/wx.onAppShow.html" target="_blank" rel="noopener">wx.onAppShow</a> 绑定监听。</p><p><strong>参数说明：</strong></p><p>与 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/wx.onAppShow.html" target="_blank" rel="noopener">wx.onAppShow</a> 一致</p><h2 id="onHide"><a href="#onHide" class="headerlink" title="onHide()"></a>onHide()</h2><p>小程序从前台进入后台时触发。也可以使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/wx.onAppHide.html" target="_blank" rel="noopener">wx.onAppHide</a> 绑定监听。</p><h2 id="onError-String-error"><a href="#onError-String-error" class="headerlink" title="onError(String error)"></a>onError(String error)</h2><p>小程序发生脚本错误或 API 调用报错时触发。也可以使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/wx.onError.html" target="_blank" rel="noopener">wx.onError</a> 绑定监听。</p><p><strong>参数说明</strong></p><p>与 wx.onError 一致</p><h2 id="onPageNotFound-Object"><a href="#onPageNotFound-Object" class="headerlink" title="onPageNotFound(Object)"></a>onPageNotFound(Object)</h2><p>基础库 1.9.90 开始支持，低版本需做兼容处理。</p><p>小程序要打开的页面不存在时触发。也可以使用 wx.onPageNotFound 绑定监听。注意事项请参考 wx.onPageNotFound。</p><p><strong>参数说明：</strong></p><p>与 wx.onPageNotFound 一致</p><h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><pre><code>//app.jsApp({  onLaunch(options) {    console.log(&quot;==onLaunch==&quot;)  },  onShow(options) {    console.log(&quot;==onShow==&quot;)  },  onHide() {    console.log(&quot;==onHide==&quot;)  },  onError(msg) {    console.log(&quot;==onError==&quot;)  },  onPageNotFound(res) {    console.log(&quot;==onPageNotFound==&quot;)  },  globalData: &#39;I am global data&#39;})</code></pre><p>我们看下日志：<br><img src="https://img-blog.csdnimg.cn/20190124205655524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>安卓的小伙伴应该能想到<br><code>onLaunch</code> 类似 <code>onCreate</code></p><p><code>onShow</code> 类似 <code>onResume</code></p><p><code>onHide</code> 类似 <code>onPouse</code></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>全局的 getApp() 函数可以用来获取到小程序 App 实例。</p><pre><code>// other.jsconst appInstance = getApp()console.log(appInstance.globalData) // I am global data</code></pre><blockquote><p>不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。<br>通过 getApp() 获取实例之后，不要私自调用生命周期函数。</p></blockquote><p><strong>～～号外～～福利～～号外～～</strong><br><strong>程序员的福音：</strong> “老曾筋骨祛痛贴”，百年祖传配方，专治<em>腰间盘</em>、<em>肩周</em>、<em>颈椎</em>、<em>坐骨神经</em>、<em>腰腿疼痛</em>等，博主亲测效果非常棒，因长期久坐写代码，坐姿不规范导致脖子疼，腰椎疼，用过之后疼痛逐渐缓解，现在已无任何疼痛，用过后让你写代码一身轻松，so easy，妈妈再也不用担心我们写代码了。<br>购买链接： <a href="https://k.weidian.com/tja7GYzB" target="_blank" rel="noopener">https://k.weidian.com/tja7GYzB</a><br><img src="https://img-blog.csdnimg.cn/20190213230334214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==" width="40%" alt></p><p><strong>扫码下方二维码，关注公众号“伟大程序猿的诞生“，回复“膏药”领取优惠券</strong><br><strong>扫码关注公众号“伟大程序猿的诞生“，更多干货新鲜文章等着你～</strong><br><img src="http://img.blog.csdn.net/20171218195006434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2l0aHViXzMzMzA0MjYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="40%" alt><br><strong>公众号回复“资料获取”，获取更多干货哦～</strong><br><strong>公众号回复“膏药”，领取优惠券哦～</strong></p><p><strong><em>有问题欢迎联系本人</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发--【Hello+World+及代码结构】(二)</title>
      <link href="/2019/02/21/wei-xin-xiao-cheng-xu/wei-xin-xiao-cheng-xu-kai-fa-hello-world-ji-dai-ma-jie-gou-er/"/>
      <url>/2019/02/21/wei-xin-xiao-cheng-xu/wei-xin-xiao-cheng-xu-kai-fa-hello-world-ji-dai-ma-jie-gou-er/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过上一篇我们已经完成了注册及开发环境的搭建，今天我们来开发我们的第一个微信小程序<br><a href="https://blog.csdn.net/github_33304260/article/details/83351575" target="_blank" rel="noopener">微信小程序开发注册流程</a></p><p>附微信开发工具下载地址：<br><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">微信开发工具</a></p><p>方便上一篇没有安装的同学。</p><h1 id="运行Hello-World"><a href="#运行Hello-World" class="headerlink" title="运行Hello World"></a>运行Hello World</h1><p>首先打开我们的微信Web开发者工具，然后用自己的<strong>微信账号扫码登陆</strong>，接着<strong>选择小程序</strong>就会看到我们接下来的画面：<br>如图：<br><img src="https://img-blog.csdnimg.cn/20190117210052863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里我们点击<strong><em>小程序/小游戏</em></strong>会出现一个测试appid，接下来点击确定，会进入到我们的开发界面：<br>如图：<br><img src="https://img-blog.csdnimg.cn/20190117210104613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时点击<strong>编译</strong>按钮<br>如图：<br><img src="https://img-blog.csdnimg.cn/2019011721011440.png" alt="在这里插入图片描述"><br>现在我们可以在左侧模拟器点击<strong>获取头像昵称</strong>，授权后就会出现我们自己的头像和昵称信息<br>如图：<br><img src="https://img-blog.csdnimg.cn/2019011721012341.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>也可以通过<strong>预览</strong>和<strong>真机调试</strong>,点击后只需要扫描二维码即可。</p><h1 id="代码构成"><a href="#代码构成" class="headerlink" title="代码构成"></a>代码构成</h1><p>如图：我们可以看到四种类型的文件<br><img src="https://img-blog.csdnimg.cn/20190117210133151.png" alt="在这里插入图片描述"></p><blockquote><p>1 .json 后缀的 JSON 配置文件</p><p>2 .wxml 后缀的 WXML 模板文件</p><p>3 .wxss 后缀的 WXSS 样式文件</p><p>4 .js 后缀的 JS 脚本逻辑文</p></blockquote><h2 id="json配置"><a href="#json配置" class="headerlink" title="json配置"></a>json配置</h2><p>我们可以看到在项目的根目录有一个 app.json 和 project.config.json，此外在 pages/logs 目录下还有一个 logs.json，我们依次来说明一下它们的用途。</p><h3 id="小程序配置-app-json"><a href="#小程序配置-app-json" class="headerlink" title="小程序配置 app.json"></a>小程序配置 app.json</h3><p>小程序根目录下的 <code>app.json</code> 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。</p><p>DEMO里的<code>app.json</code>代码如下：</p><pre><code>{  &quot;pages&quot;:[    &quot;pages/index/index&quot;,    &quot;pages/logs/logs&quot;  ],  &quot;window&quot;:{    &quot;backgroundTextStyle&quot;:&quot;light&quot;,    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,    &quot;navigationBarTextStyle&quot;:&quot;black&quot;  }}</code></pre><p>我们简单说一下这个配置各个项的含义:</p><blockquote><p>1、pages字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。</p><p>2、window字段 —— 定义小程序所有页面的顶部背景颜色，文字颜色定义等。</p></blockquote><p>更多详细属性参见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html" target="_blank" rel="noopener">小程序的配置 app.json</a></p><h3 id="工具配置-project-config-json"><a href="#工具配置-project-config-json" class="headerlink" title="工具配置 project.config.json"></a>工具配置 project.config.json</h3><p>工具配置就相当于我们对当前的<code>idea</code>进行了界面配置、编译配置等，只不过小程序把这个配置文件写入了工程中，当我们换一台电脑打开同一个工程，你会发现还是原来的味道。避免了有些同学换台电脑就不会编程的痛苦。</p><p>我们看一下<code>DEMO</code>里面的工具配置文件：</p><pre><code>{    &quot;description&quot;: &quot;项目配置文件&quot;,    &quot;packOptions&quot;: {        &quot;ignore&quot;: []    },    &quot;setting&quot;: {        &quot;urlCheck&quot;: true,        &quot;es6&quot;: true,        &quot;postcss&quot;: true,        &quot;minified&quot;: true,        &quot;newFeature&quot;: true,        &quot;autoAudits&quot;: false    },    &quot;compileType&quot;: &quot;miniprogram&quot;,    &quot;libVersion&quot;: &quot;2.0.4&quot;,    &quot;appid&quot;: &quot;wxe7c297ecaaaa0735&quot;,    &quot;projectname&quot;: &quot;%E5%B0%8F%E7%A8%8B%E5%BA%8F&quot;,    &quot;debugOptions&quot;: {        &quot;hidedInDevtools&quot;: []    },    &quot;isGameTourist&quot;: false,    &quot;condition&quot;: {        &quot;search&quot;: {            &quot;current&quot;: -1,            &quot;list&quot;: []        },        &quot;conversation&quot;: {            &quot;current&quot;: -1,            &quot;list&quot;: []        },        &quot;game&quot;: {            &quot;currentL&quot;: -1,            &quot;list&quot;: []        },        &quot;miniprogram&quot;: {            &quot;current&quot;: -1,            &quot;list&quot;: []        }    }}</code></pre><p>我们简单说一下这个配置各个项的含义:<br><code>packOptions</code> 用以配置项目在打包过程中的选项。打包是预览、上传时对项目进行的必须步骤。<br><code>setting</code> 项目设置，包括（是否启用 es6 转 es5，上传代码时样式是否自动补全、上传代码时是否自动压缩、是否进行代码保护等）<br><code>compileType</code> 编译类型<br><code>appid</code> 项目的 appid，只在新建项目时读取<br><code>projectname</code> 项目名字，只在新建项目时读取<br><code>debugOptions</code> 调试配置选项</p><p>更多详细参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html" target="_blank" rel="noopener">开发者工具的配置</a></p><h3 id="页面配置-page-json"><a href="#页面配置-page-json" class="headerlink" title="页面配置 page.json"></a>页面配置 page.json</h3><p>这里的 page.json 其实用来表示 pages/logs 目录下的 logs.json 这类和小程序页面相关的配置。</p><p>如果你整个小程序的风格是蓝色调，那么你可以在 app.json 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了 page.json，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。</p><p>我们来看一下<code>DEMO</code>中的<code>logs.json</code>和<code>index.json</code></p><p><code>logs.json</code>中重新定义了标题</p><pre><code>{  &quot;navigationBarTitleText&quot;: &quot;查看启动日志&quot;}</code></pre><p><code>index.json</code>中没有做任何修改，也就是完全使用<code>app.json</code>中的配置信息</p><pre><code>{}</code></pre><p>其他配置项细节可以参考文档 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">页面配置</a> 。</p><h2 id="WXML-模板"><a href="#WXML-模板" class="headerlink" title="WXML 模板"></a>WXML 模板</h2><p>从事过网页编程的人知道，网页编程采用的是 <code>HTML + CSS + JS</code> 这样的组合，其中<code>HTML</code> 是用来描述当前这个页面的结构，<code>CSS</code> 用来描述页面的样子，<code>JS</code> 通常是用来处理这个页面和用户的交互。</p><p>同样道理，在小程序中也有同样的角色，其中 WXML 充当的就是类似 HTML 的角色。<br>我们来看一下首页<code>pages/index/index.wxml</code></p><pre><code>&lt;!--index.wxml--&gt;&lt;view class=&quot;container&quot;&gt;  &lt;view class=&quot;userinfo&quot;&gt;    &lt;button wx:if=&quot;{{!hasUserInfo && canIUse}}&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt; 获取头像昵称 &lt;/button&gt;    &lt;block wx:else&gt;      &lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;{{userInfo.avatarUrl}}&quot; mode=&quot;cover&quot;&gt;&lt;/image&gt;      &lt;text class=&quot;userinfo-nickname&quot;&gt;{{userInfo.nickName}}&lt;/text&gt;    &lt;/block&gt;  &lt;/view&gt;  &lt;view class=&quot;usermotto&quot;&gt;    &lt;text class=&quot;user-motto&quot;&gt;{{motto}}&lt;/text&gt;  &lt;/view&gt;&lt;/view&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/20190117210153798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>和 HTML 非常相似，WXML 由标签、属性等等构成。但是也有很多不一样的地方，我们来一一阐述一下：</p><blockquote><p>1、标签名字有点不一样</p><p>往往写 HTML 的时候，经常会用到的标签是 div, p, span，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。小程序的将常用的组件封装了起来，用 view, button, text 等等</p><p>2、多了一些 wx:if 这样的属性以及 双花括号 这样的表达式</p><p>通过 双花括号 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if/else, for等控制能力，在小程序里边，这些控制能力都用 wx: 开头的属性来表达。</p></blockquote><p>更详细的文档可以参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/index.html" target="_blank" rel="noopener">WXML</a></p><h2 id="WXSS-样式"><a href="#WXSS-样式" class="headerlink" title="WXSS 样式"></a>WXSS 样式</h2><p>WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。</p><blockquote><p>1、新增了尺寸单位。在写 CSS 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。WXSS 在底层支持新的尺寸单位 rpx ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。</p><p>2、提供了全局的样式和局部样式。和前边 app.json, page.json 的概念相同，你可以写一个 app.wxss 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 page.wxss 仅对当前页面生效。</p><p>3、此外 WXSS 仅支持部分 CSS 选择器</p></blockquote><pre><code>/**index.wxss**/.userinfo {  display: flex;  flex-direction: column;  align-items: center;}.userinfo-avatar {  width: 128rpx;  height: 128rpx;  margin: 20rpx;  border-radius: 50%;}.userinfo-nickname {  color: #aaa;}.usermotto {  margin-top: 200px;}</code></pre><p>都是一些常见的属性，看名知意。</p><p>更详细的文档可以参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html" target="_blank" rel="noopener">WXSS</a> 。</p><h2 id="JS-交互逻辑"><a href="#JS-交互逻辑" class="headerlink" title="JS 交互逻辑"></a>JS 交互逻辑</h2><p>一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 JS 脚本文件来处理用户的操作。</p><pre><code>&lt;view&gt;{{ msg }}&lt;/view&gt; &lt;button bindtap=&quot;clickMe&quot;&gt;点击我&lt;/button&gt;</code></pre><p>点击 button 按钮的时候，我们希望把界面上 msg 显示成 “Hello World”，于是我们在 button 上声明一个属性: bindtap ，在 JS 文件里边声明了 clickMe 方法来响应这次点击操作：</p><pre><code>Page({  clickMe() {    this.setData({msg: &#39;Hello World&#39;})  }})</code></pre><p>响应用户的操作就是这么简单，更详细的事件后续介绍。</p><p>此外，小程序还给我们提供了更多丰富的API，用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的 QuickStart 例子中，在 pages/index/index.js 就调用了 wx.getUserInfo 获取微信用户的头像和昵称，最后通过 setData 把获取到的信息显示到界面上。<br>更多详细API后续介绍。</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/" target="_blank" rel="noopener">小程序API</a></p><p><strong>～～号外～～福利～～号外～～</strong><br><strong>程序员的福音：</strong> “老曾筋骨祛痛贴”，百年祖传配方，专治<em>腰间盘</em>、<em>肩周</em>、<em>颈椎</em>、<em>坐骨神经</em>、<em>腰腿疼痛</em>等，博主亲测效果非常棒，因长期久坐写代码，坐姿不规范导致脖子疼，腰椎疼，用过之后疼痛逐渐缓解，现在已无任何疼痛，用过后让你写代码一身轻松，so easy，妈妈再也不用担心我们写代码了。<br>购买链接： <a href="https://k.weidian.com/tja7GYzB" target="_blank" rel="noopener">https://k.weidian.com/tja7GYzB</a><br><img src="https://img-blog.csdnimg.cn/20190213230334214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==" width="40%" alt></p><p><strong>扫码下方二维码，关注公众号“伟大程序猿的诞生“，回复“膏药”领取优惠券</strong><br><strong>扫码关注公众号“伟大程序猿的诞生“，更多干货新鲜文章等着你～</strong><br><img src="http://img.blog.csdn.net/20171218195006434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2l0aHViXzMzMzA0MjYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="40%" alt><br><strong>公众号回复“资料获取”，获取更多干货哦～</strong><br><strong>公众号回复“膏药”，领取优惠券哦～</strong></p><p><strong><em>有问题欢迎联系本人</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android TV 开发总结【RecycleView】</title>
      <link href="/2019/02/21/androidtv/androidtv-kai-fa-zong-jie-recycleview/"/>
      <url>/2019/02/21/androidtv/androidtv-kai-fa-zong-jie-recycleview/</url>
      
        <content type="html"><![CDATA[<p>在TV开发中RecycleView的使用是最让人头疼的经常会出现焦点丢失。因为当item未显示时不能获取焦点。所以当我们按上下键时经常丢失焦点或者焦点乱跳。要解决这个问题我们必须要手动控制RecyclerView 的按键和焦点移动。</p><p>所以我们这里需要需要自定义RecycleView。</p><p>代码如下，各个方法作用在注视中已添加：</p><pre><code>public class TvRecyclerView extends RecyclerView{    //正常跟随滚动    private static final int SCROLL_NORMAL = 0;    //居中滚动    private static final int SCROLL_FOLLOW = 1;    //滚动模式    private int scrollModel;    //当前选中的position    private int mSelectedPosition = 0;    //下一个聚焦的View    private View mNextFocused;    public TvRecyclerViewNew(Context context)    {        this(context, null);    }    public TvRecyclerViewNew(Context context, AttributeSet attrs)    {        this(context, attrs, -1);    }    public TvRecyclerViewNew(Context context, AttributeSet attrs, int defStyle)    {        super(context, attrs, defStyle);        init(context, attrs, defStyle);    }    /**     * 初始化     *     * @param context     * @param attrs     * @param defStyle     */    private void init(Context context, AttributeSet attrs, int defStyle)    {        initView();        initAttr(attrs);    }    /**     * 初始化View     * 为避免recycleview焦点混乱常用的一些设置     */    private void initView()    {        setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);        setHasFixedSize(true);        setWillNotDraw(true);        setOverScrollMode(View.OVER_SCROLL_NEVER);        setChildrenDrawingOrderEnabled(true);        setClipChildren(false);        setClipToPadding(false);        setClickable(false);        setFocusable(true);        setFocusableInTouchMode(true);        /**         防止RecyclerView刷新时焦点不错乱bug的步骤如下:         (1)adapter执行setHasStableIds(true)方法         (2)重写getItemId()方法,让每个view都有各自的id         (3)RecyclerView的动画必须去掉         */        setItemAnimator(null);    }    /**     * 初始化样式     * 是否居中滚动     * @param attrs     */    private void initAttr(AttributeSet attrs)    {        TypedArray typeArray = getContext().obtainStyledAttributes(attrs, R.styleable.TvRecyclerView);        scrollModel = typeArray.getInteger(R.styleable.TvRecyclerView_scrollMode, 0);    }    /**     * 恢复回收之前的状态     * @param state     */    @Override    protected void onRestoreInstanceState(Parcelable state)    {        Bundle bundle = (Bundle) state;        Parcelable superData = bundle.getParcelable(&quot;super_data&quot;);        super.onRestoreInstanceState(superData);        setItemSelected(bundle.getInt(&quot;select_pos&quot;, 0));    }    /**     * 回收之前保存状态     * @return     */    @Override    protected Parcelable onSaveInstanceState()    {        Bundle bundle = new Bundle();        Parcelable superData = super.onSaveInstanceState();        bundle.putParcelable(&quot;super_data&quot;, superData);        bundle.putInt(&quot;select_pos&quot;, mSelectedPosition);        return bundle;    }    /**     * 解决4.4版本抢焦点的问题     * @return     */    @Override    public boolean isInTouchMode()    {        if (Build.VERSION.SDK_INT == 19)        {            return !(hasFocus() &amp;&amp; !super.isInTouchMode());        } else        {            return super.isInTouchMode();        }    }    @Override    public void requestChildFocus(View child, View focused)    {        super.requestChildFocus(child, focused);    }    @Override    public boolean requestChildRectangleOnScreen(View child, Rect rect, boolean immediate)    {        final int parentLeft = getPaddingLeft();        final int parentRight = getWidth() - getPaddingRight();        final int parentTop = getPaddingTop();        final int parentBottom = getHeight() - getPaddingBottom();        final int childLeft = child.getLeft() + rect.left;        final int childTop = child.getTop() + rect.top;        final int childRight = childLeft + rect.width();        final int childBottom = childTop + rect.height();        final int offScreenLeft = Math.min(0, childLeft - parentLeft);        final int offScreenRight = Math.max(0, childRight - parentRight);        final int offScreenTop = Math.min(0, childTop - parentTop);        final int offScreenBottom = Math.max(0, childBottom - parentBottom);        final boolean canScrollHorizontal = getLayoutManager().canScrollHorizontally();        final boolean canScrollVertical = getLayoutManager().canScrollVertically();        // Favor the &quot;start&quot; layout direction over the end when bringing one side or the other        // of a large rect into view. If we decide to bring in end because start is already        // visible, limit the scroll such that start won&#39;t go out of bounds.        final int dx;        if (canScrollHorizontal)        {            if (ViewCompat.getLayoutDirection(this) == ViewCompat.LAYOUT_DIRECTION_RTL)            {                dx = offScreenRight != 0 ? offScreenRight                        : Math.max(offScreenLeft, childRight - parentRight);            } else            {                dx = offScreenLeft != 0 ? offScreenLeft                        : Math.min(childLeft - parentLeft, offScreenRight);            }        } else        {            dx = 0;        }        // Favor bringing the top into view over the bottom. If top is already visible and        // we should scroll to make bottom visible, make sure top does not go out of bounds.        final int dy;        if (canScrollVertical)        {            dy = offScreenTop != 0 ? offScreenTop : Math.min(childTop - parentTop, offScreenBottom);        } else        {            dy = 0;        }        if (dx != 0 || dy != 0)        {            if (immediate)            {                scrollBy(dx, dy);            } else            {                smoothScrollBy(dx, dy);            }            postInvalidate();            return true;        }        return false;    }    /**     * 判断是垂直，还是横向.     */    private boolean isVertical()    {        LayoutManager manager = getLayoutManager();        if (manager != null)        {            LinearLayoutManager layout = (LinearLayoutManager) getLayoutManager();            return layout.getOrientation() == LinearLayoutManager.VERTICAL;        }        return false;    }    /**     * 滚动的相关响应     * computeScroll在父控件执行drawChild时，会调用这个方法     */    @Override    public void computeScroll()    {        super.computeScroll();        //滚动后更新当前选中的position        if (mNextFocused != null)        {            mSelectedPosition = getChildAdapterPosition(mNextFocused);        } else        {            mSelectedPosition = getChildAdapterPosition(getFocusedChild());        }    }    /**     * 返回迭代的绘制子类索引。如果你想改变子类的绘制顺序就要重写该方法     * 提示：为了能够调用该方法，你必须首先调用setChildrenDrawingOrderEnabled(boolean)来允许子类排序     *     * @param childCount 子类个数     * @param i 当前迭代顺序     * @return 绘制该迭代子类的索引     */    @Override    protected int getChildDrawingOrder(int childCount, int i)    {        View view = getFocusedChild();        if (null != view)        {            int position = getChildAdapterPosition(view) - getFirstVisiblePosition();            if (position &lt; 0)            {                return i;            } else            {                if (i == childCount - 1)                {                    if (position &gt; i)                    {                        position = i;                    }                    return position;                }                if (i == position)                {                    return childCount - 1;                }            }        }        return i;    }    @Override    public boolean dispatchKeyEvent(KeyEvent event)    {        boolean result = super.dispatchKeyEvent(event);        View focusView = this.getFocusedChild();        if (focusView == null)        {            return result;        } else        {            if (event.getAction() == KeyEvent.ACTION_UP)            {                //不能拦截KeyEvent.KEYCODE_BACK                //否则onBackPress不会触发                if(event.getKeyCode() == KeyEvent.KEYCODE_BACK){                    return super.dispatchKeyEvent(event);                }else {                    return true;                }            } else            {                switch (event.getKeyCode())                {                    case KeyEvent.KEYCODE_DPAD_RIGHT:                        View rightView = mNextFocused = FocusFinder.getInstance().findNextFocus(this, focusView, View.FOCUS_RIGHT);                        setViewPosition(mNextFocused);                        if (rightView != null)                        {                            rightView.requestFocus();                            return true;                        } else                        {                            return false;                        }                    case KeyEvent.KEYCODE_DPAD_LEFT:                        View leftView = mNextFocused = FocusFinder.getInstance().findNextFocus(this, focusView, View.FOCUS_LEFT);                        setViewPosition(mNextFocused);                        if (leftView != null)                        {                            mSelectedPosition = getChildAdapterPosition(leftView);                        } else                        {                            mSelectedPosition = getChildAdapterPosition(getFocusedChild());                        }                        if (leftView != null)                        {                            leftView.requestFocus();                            return true;                        } else                        {                            return false;                        }                    case KeyEvent.KEYCODE_DPAD_DOWN:                        View downView = mNextFocused = FocusFinder.getInstance().findNextFocus(this, focusView, View.FOCUS_DOWN);                        setViewPosition(mNextFocused);                        if (downView != null)                        {                            downView.requestFocus();                            if (scrollModel == SCROLL_NORMAL)                            {                                //跟随滚动直接返回true                                return true;                            } else                            {                                //居中滚动计算出滚动距离，将view滚动到中间                                int downOffset = downView.getTop() + downView.getHeight() / 2 - getHeight() / 2;                                this.smoothScrollBy(0, downOffset);                                return true;                            }                        } else                        {                            return isBottomEdge(getLayoutManager().getPosition(this.getFocusedChild()));                        }                    case KeyEvent.KEYCODE_DPAD_UP:                        View upView = mNextFocused = FocusFinder.getInstance().findNextFocus(this, focusView, View.FOCUS_UP);                        setViewPosition(mNextFocused);                        if (upView != null)                        {                            upView.requestFocus();                            if (scrollModel == SCROLL_NORMAL)                            {                                return true;                            } else                            {                                int upOffset = getHeight() / 2 - (upView.getBottom() - upView.getHeight() / 2);                                this.smoothScrollBy(0, -upOffset);                                return true;                            }                        } else                        {                            return isTopEdge(getLayoutManager().getPosition(this.getFocusedChild())) ;                        }                }            }        }        return result;    }    private void setViewPosition(View mNextFocused){        if(mNextFocused != null){            mSelectedPosition = getChildAdapterPosition(mNextFocused);        }else {            mSelectedPosition = getChildAdapterPosition(getFocusedChild());        }    }    //防止Activity时,RecyclerView崩溃    @Override    protected void onDetachedFromWindow()    {        if (getLayoutManager() != null)        {            super.onDetachedFromWindow();        }    }    /**     * 设置选中的item     * @param position     */    public void setItemSelected(int position)    {        if (mSelectedPosition == position)        {            return;        }        if (position &gt;= getAdapter().getItemCount())        {            position = getAdapter().getItemCount() - 1;        }        mSelectedPosition = position;        requestLayout();    }    /**     * 是否是最右边的item，如果是竖向，表示右边，如果是横向表示下边     *     * @param childPosition     * @return     */    public boolean isRightEdge(int childPosition)    {        LayoutManager layoutManager = getLayoutManager();        if (layoutManager instanceof GridLayoutManager)        {            GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager;            GridLayoutManager.SpanSizeLookup spanSizeLookUp = gridLayoutManager.getSpanSizeLookup();            int totalSpanCount = gridLayoutManager.getSpanCount();            int totalItemCount = gridLayoutManager.getItemCount();            int childSpanCount = 0;            for (int i = 0; i &lt;= childPosition; i++)            {                childSpanCount += spanSizeLookUp.getSpanSize(i);            }            if (isVertical())            {                if (childSpanCount % gridLayoutManager.getSpanCount() == 0)                {                    return true;                }            } else            {                int lastColumnSize = totalItemCount % totalSpanCount;                if (lastColumnSize == 0)                {                    lastColumnSize = totalSpanCount;                }                if (childSpanCount &gt; totalItemCount - lastColumnSize)                {                    return true;                }            }        } else if (layoutManager instanceof LinearLayoutManager)        {            if (isVertical())            {                return true;            } else            {                return childPosition == getLayoutManager().getItemCount() - 1;            }        }        return false;    }    /**     * 是否是最左边的item，如果是竖向，表示左方，如果是横向，表示上边     *     * @param childPosition     * @return     */    public boolean isLeftEdge(int childPosition)    {        LayoutManager layoutManager = getLayoutManager();        if (layoutManager instanceof GridLayoutManager)        {            GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager;            GridLayoutManager.SpanSizeLookup spanSizeLookUp = gridLayoutManager.getSpanSizeLookup();            int totalSpanCount = gridLayoutManager.getSpanCount();            int childSpanCount = 0;            for (int i = 0; i &lt;= childPosition; i++)            {                childSpanCount += spanSizeLookUp.getSpanSize(i);            }            if (isVertical())            {                if (childSpanCount % gridLayoutManager.getSpanCount() == 1)                {                    return true;                }            } else            {                if (childSpanCount &lt;= totalSpanCount)                {                    return true;                }            }        } else if (layoutManager instanceof LinearLayoutManager)        {            if (isVertical())            {                return true;            } else            {                return childPosition == 0;            }        }        return false;    }    /**     * 是否是最上边的item，以recyclerview的方向做参考     *     * @param childPosition     * @return     */    public boolean isTopEdge(int childPosition)    {        LayoutManager layoutManager = getLayoutManager();        if (layoutManager instanceof GridLayoutManager)        {            GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager;            GridLayoutManager.SpanSizeLookup spanSizeLookUp = gridLayoutManager.getSpanSizeLookup();            int totalSpanCount = gridLayoutManager.getSpanCount();            int childSpanCount = 0;            for (int i = 0; i &lt;= childPosition; i++)            {                childSpanCount += spanSizeLookUp.getSpanSize(i);            }            if (isVertical())            {                if (childSpanCount &lt;= totalSpanCount)                {                    return true;                }            } else            {                if (childSpanCount % totalSpanCount == 1)                {                    return true;                }            }        } else if (layoutManager instanceof LinearLayoutManager)        {            if (isVertical())            {                return childPosition == 0;            } else            {                return true;            }        }        return false;    }    /**     * 是否是最下边的item，以recyclerview的方向做参考     *     * @param childPosition     * @return     */    public boolean isBottomEdge(int childPosition)    {        LayoutManager layoutManager = getLayoutManager();        if (layoutManager instanceof GridLayoutManager)        {            GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager;            GridLayoutManager.SpanSizeLookup spanSizeLookUp = gridLayoutManager.getSpanSizeLookup();            int itemCount = gridLayoutManager.getItemCount();            int childSpanCount = 0;            int totalSpanCount = gridLayoutManager.getSpanCount();            for (int i = 0; i &lt;= childPosition; i++)            {                childSpanCount += spanSizeLookUp.getSpanSize(i);            }            if (isVertical())            {                //最后一行item的个数                int lastRowCount = itemCount % totalSpanCount;                if (lastRowCount == 0)                {                    lastRowCount = gridLayoutManager.getSpanCount();                }                if (childSpanCount &gt; itemCount - lastRowCount)                {                    return true;                }            } else            {                if (childSpanCount % totalSpanCount == 0)                {                    return true;                }            }        } else if (layoutManager instanceof LinearLayoutManager)        {            if (isVertical())            {                return childPosition == getLayoutManager().getItemCount() - 1;            } else            {                return true;            }        }        return false;    }    /**     * 判断是否已经滑动到底部     *     * @param recyclerView     * @return     */    private boolean isVisBottom(RecyclerView recyclerView)    {        LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();        int lastVisibleItemPosition = layoutManager.findLastVisibleItemPosition();        int visibleItemCount = layoutManager.getChildCount();        int totalItemCount = layoutManager.getItemCount();        if (visibleItemCount &gt; 0 &amp;&amp; lastVisibleItemPosition == totalItemCount - 1)        {            return true;        } else        {            return false;        }    }    public int getFirstVisiblePosition()    {        if (getChildCount() == 0)            return 0;        else            return getChildAdapterPosition(getChildAt(0));    }    public int getLastVisiblePosition()    {        final int childCount = getChildCount();        if (childCount == 0)            return 0;        else            return getChildAdapterPosition(getChildAt(childCount - 1));    }    private int getFreeWidth()    {        return getWidth() - getPaddingLeft() - getPaddingRight();    }    private int getFreeHeight()    {        return getHeight() - getPaddingTop() - getPaddingBottom();    }    public int getSelectedPosition()    {        return mSelectedPosition;    }    public void setSelectionPostion(int selectionPostion)    {        mSelectedPosition = selectionPostion;    }}</code></pre><p>最后一点不要忘记在<code>attrs.xml</code>中添加TvRecycelview样式：</p><pre><code>&lt;!--TvRecycelvie滚动--&gt;    &lt;attr name=&quot;scrollMode&quot; &gt;        &lt;enum name=&quot;normalScroll&quot; value=&quot;0&quot;/&gt;        &lt;enum name=&quot;followScroll&quot; value=&quot;1&quot;/&gt;    &lt;/attr&gt;    &lt;!--TvRecycelview样式--&gt;    &lt;declare-styleable name=&quot;TvRecyclerView&quot;&gt;        &lt;attr name=&quot;scrollMode&quot;/&gt;    &lt;/declare-styleable&gt;</code></pre><p><strong>～～号外～～福利～～号外～～</strong><br><strong>程序员的福音：</strong> “老曾筋骨祛痛贴”，百年祖传配方，专治<em>腰间盘</em>、<em>肩周</em>、<em>颈椎</em>、<em>坐骨神经</em>、<em>腰腿疼痛</em>等，博主亲测效果非常棒，因长期久坐写代码，坐姿不规范导致脖子疼，腰椎疼，用过之后疼痛逐渐缓解，现在已无任何疼痛，用过后让你写代码一身轻松，so easy，妈妈再也不用担心我们写代码了。<br>购买链接： <a href="https://k.weidian.com/tja7GYzB" target="_blank" rel="noopener">https://k.weidian.com/tja7GYzB</a><br><img src="https://img-blog.csdnimg.cn/20190213230334214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==" width="40%" alt></p><p><strong>扫码下方二维码，关注公众号“伟大程序猿的诞生“，回复“膏药”领取优惠券</strong><br><strong>扫码关注公众号“伟大程序猿的诞生“，更多干货新鲜文章等着你～</strong><br><img src="http://img.blog.csdn.net/20171218195006434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2l0aHViXzMzMzA0MjYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="40%" alt><br><strong>公众号回复“资料获取”，获取更多干货哦～</strong><br><strong>公众号回复“膏药”，领取优惠券哦～</strong></p><p><strong><em>有问题欢迎联系本人</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> AndroidTV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AndroidTV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android TV 开发总结【焦点】</title>
      <link href="/2019/02/21/androidtv/androidtv-kai-fa-zong-jie-jiao-dian/"/>
      <url>/2019/02/21/androidtv/androidtv-kai-fa-zong-jie-jiao-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、焦点获取"><a href="#一、焦点获取" class="headerlink" title="一、焦点获取"></a>一、焦点获取</h1><p>首先，TV端的开发和我们手机端开发最大的区别就在于TV端存在焦点的概念。</p><p>如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/25/164362d6e0f20882?w=524&h=194&f=gif&s=1255532" width="80%" alt></p><p>可想而知，手机端我们直接通过点击\长按某个区域处理响应事件处，但是TV端只能通过遥控器的上下左右来操控焦点，从而选中特定的区域处理相应事件。</p><p>在TV开发中没有以前我手机端的dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent 事件来分发，而需要使用dispatchKeyEvent、onKeyDown、onKeyLisenter 等事件来分发处理焦点事件传递。</p><p>然而TV端焦点没有什么好办法可以全局控制焦点，需要我们自己来想办法规定焦点走向，一旦焦点没有处理好就会造成焦点丢失。</p><blockquote><p>android提供了一些焦点相关的属性，在现有的框架层下通过设置View的属性来获得焦点：</p><ul><li>android:focusable：设置一个控件能否获得焦点</li><li>android:nextFocusDown：(当按下键时)下一个获得焦点的控件</li><li>android:nextFocusDown：(当按下键时)下一个获得焦点的控件</li><li>android:nextFocusLeft：(当按下键时)下一个获得焦点的控件</li><li>android:nextFocusRight：(当按下键时)下一个获得焦点的控<br><strong>注意：</strong>如果按下某个方向键时，想让焦点停留在自身，可以使用<code>android:nextFocusRight:&quot;@null&quot;</code>或者<code>android:nextFocusRight:&quot;@id/自身id&quot;</code></li></ul></blockquote><p>栗子:如下图：</p><p>我们想要实现<strong>firstView</strong>（按右键）–&gt;<strong>secondView</strong>(按下键)–&gt;<strong>threadView</strong>（按上键）–&gt;<strong>firstView</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/6/25/16435fbde8759b15?w=869&h=524&f=png&s=7699" width="70%" alt></p><blockquote><p><strong>步骤：</strong></p><ul><li>第一步：让这<strong>firstView、secondView、threadView</strong>获取焦点</li><li>第二步：控制这三个View的移动轨迹</li><li>注意：fourthView没有涉及到焦点，我们不用做任何处理</li></ul></blockquote><p>示例：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;View        android:id=&quot;@+id/firstView&quot;        android:layout_width=&quot;40dp&quot;        android:layout_height=&quot;40dp&quot;        android:focusable=&quot;true&quot;        android:nextFocusDown=&quot;@null&quot;        android:nextFocusLeft=&quot;@null&quot;        android:nextFocusRight=&quot;@id/secondView&quot;        android:nextFocusUp=&quot;@null&quot; /&gt;    &lt;View        android:id=&quot;@+id/secondView&quot;        android:layout_width=&quot;60dp&quot;        android:layout_height=&quot;60dp&quot;        android:focusable=&quot;true&quot;        android:nextFocusDown=&quot;@id/threadView&quot;        android:nextFocusLeft=&quot;@null&quot;        android:nextFocusRight=&quot;@null&quot;        android:nextFocusUp=&quot;@null&quot; /&gt;    &lt;View        android:id=&quot;@+id/threadView&quot;        android:layout_width=&quot;30dp&quot;        android:layout_height=&quot;30dp&quot;        android:focusable=&quot;true&quot;        android:nextFocusDown=&quot;@null&quot;        android:nextFocusLeft=&quot;@null&quot;        android:nextFocusRight=&quot;@null&quot;        android:nextFocusUp=&quot;@id/firstView&quot; /&gt;    &lt;View        android:id=&quot;@+id/fourthView&quot;        android:layout_width=&quot;100dp&quot;        android:layout_height=&quot;40dp&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p>也可以在代码中设置：</p><pre><code>threadView.setNextFocusLeftId(R.id.firstView);secondView.setNextFocusDownId(R.id.threadView);</code></pre><blockquote><p><strong>注意：</strong></p><ul><li>开发过程中我们有时需要布局初始化就有一个View是聚焦状态，那么可以使用<code>requestFocus()</code>来请求焦点。</li></ul></blockquote><p>那么此时问题来了，我们肉眼如何知道焦点在哪一个View上？</p><p>此时就需要我们对焦点选中的View进行样式改变，有一下两种方法：</p><h1 id="二、聚焦时View样式"><a href="#二、聚焦时View样式" class="headerlink" title="二、聚焦时View样式"></a>二、聚焦时View样式</h1><p><strong>方法一：</strong></p><pre><code> android:background：设置背景的drawable android:textColor：设置字体颜色</code></pre><p>对应的xml文件：<br>drawable的xml文件，焦点选中时显示为<em>keyboard_add</em>，否则显示为<em>keyboard_add_sel</em></p><pre><code>&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item android:drawable=&quot;@drawable/keyboard_add_sel&quot; android:state_focused=&quot;true&quot; /&gt;    &lt;item android:drawable=&quot;@drawable/keyboard_add&quot; android:state_focused=&quot;false&quot;/&gt;&lt;/selector&gt;</code></pre><p>color的xml文件，焦点选中时显示#4194ff（蓝色），否则显示#29ffffff（灰色）</p><pre><code>&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item android:color=&quot;#4194ff&quot; android:state_focused=&quot;true&quot;/&gt;    &lt;item android:color=&quot;#29ffffff&quot; android:state_focused=&quot;false&quot;/&gt;&lt;/selector&gt;</code></pre><p><strong>方法二：</strong></p><p>对该View进行焦点监听（setOnFocusChangeListener），在该监听事件中进行处理</p><pre><code>view.setOnFocusChangeListener(new View.OnFocusChangeListener(){    @Override    public void onFocusChange(View view, boolean hasFocus)    {        if(hasFocus){            //获得焦点            view.xxxxx();        }else{            //失去焦点            view.xxxxx();        }    }});</code></pre><h1 id="三、按键事件如何分发？"><a href="#三、按键事件如何分发？" class="headerlink" title="三、按键事件如何分发？"></a>三、按键事件如何分发？</h1><p>首先看一下经常会遇到的坑，带着问题去探究整个过程</p><p>尽管官方提供了基本用法，但是我们开发中任然会遇到焦点相关的问题：</p><blockquote><ul><li>我明明指定了焦点，为什么焦点还是丢失了？</li><li>onKeyDown为什么有时获取不到按键事件？</li><li>没有做任何焦点处理的View会获取焦点？</li><li>对RecycleView设置nextFocusDown没有效果？</li></ul></blockquote><p>接下来我们带着问题从源码角度来探究一下：</p><p>在手机端，我们通过滑动，触摸，长按等，会产生一个触摸事件（MotionEvent）。</p><p>同理：在遥控器上我们按“上”，“下”，“左”，“右”，“ok”，“返回”等按键时，会产生一个按键事件（KeyEvent），焦点的处理就在KeyEvent中分发处理。</p><p>所以此时我们需要从ViewRootImpl入手，来具体分析焦点是如何分发的？。那么此时有同学会问，为什么是从ViewRootImpl入手？</p><h2 id="3-1-什么是ViewRootImpl？"><a href="#3-1-什么是ViewRootImpl？" class="headerlink" title="3.1 什么是ViewRootImpl？"></a>3.1 什么是ViewRootImpl？</h2><p>官方定义：The top of a view hierarchy, implementing the needed protocol between View and the WindowManager.</p><p>翻译： 视图层次结构的顶部，在视图和窗口管理器之间实现所需的协议。</p><p><strong>这里简单总结一下几点：</strong></p><blockquote><ul><li>1、<code>ViewRootImpl</code>是链接<code>WindowManager</code>和<code>DecorView</code>的纽带</li><li>2、完成<code>View</code>的绘制，包括<code>measure`</code>、layout<code>、</code>draw`过程。</li><li>3、向<code>DecorView</code>分发收到的用户发起的<code>event</code>事件，如按键，触屏等事件。</li></ul></blockquote><p>ViewRootImpl本身并不是一个View，可以看作是View树的管理者。而这里的成员变量mView就是DecorView，它指向的对象跟Window和Activity的mDecor指向的对象是同一个对象。所有的View组成了一个View树，每一个View都是树中的一个节点，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/28/164443d7b898b296?w=539&amp;h=437&amp;f=png&amp;s=30616" alt><br>最上层的根是DecorView，中间是各ViewGroup，最下层是View。</p><p>所以我们知道知道<code>keyevent</code>的分发源头是<code>ViewRootImpl</code>，它是整个View树的管理者，首先走了mView的dispatchKeyEvent，也就是从DecorView开始进行KeyEvent的分发。</p><h2 id="3-2-keyevent分发流程？"><a href="#3-2-keyevent分发流程？" class="headerlink" title="3.2 keyevent分发流程？"></a>3.2 keyevent分发流程？</h2><p>Android焦点事件的分发是在ViewRootImpl的内部类ViewPostImeInputStage中的processKeyEvent方法进行的，具体流程看代码：</p><p><strong>本文以（API27）为例</strong></p><h3 id="（1）processKeyEvent方法的具体实现"><a href="#（1）processKeyEvent方法的具体实现" class="headerlink" title="（1）processKeyEvent方法的具体实现"></a>（1）processKeyEvent方法的具体实现</h3><pre><code>private int processKeyEvent(QueuedInputEvent q) {    final KeyEvent event = (KeyEvent)q.mEvent;    //由dispatchKeyEvent进行焦点的分发，如果dispatchKeyEvent方法返回true，那么下面的焦点查找步骤就不会继续了。    //这里mView是Activity的顶层容器DecorView，是一FrameLayout。    //所以这里的dispatchKeyEvent方法执行的是ViewGroup的dispatchKeyEvent()方法    if (mView.dispatchKeyEvent(event)) {        return FINISH_HANDLED;    }    // 是否终止事件    // 当根视图不存在就会停止下面的步骤    // 属于保护措施    if (shouldDropInputEvent(q)) {        return FINISH_NOT_HANDLED;    }    int groupNavigationDirection = 0;    //对TAB键做特殊处理    //判断仅按下TAB还是TAB和其他键的组合    //metaStateHasModifiers()方法根据指定的META状态按下指定的按键键，则返回true.如果按下不同的修改键组合，则返回false.    //通过下面的方法判断groupNavigationDirection的方向    if (event.getAction() == KeyEvent.ACTION_DOWN            &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_TAB) {        if (KeyEvent.metaStateHasModifiers(event.getMetaState(), KeyEvent.META_META_ON)) {            groupNavigationDirection = View.FOCUS_FORWARD;        } else if (KeyEvent.metaStateHasModifiers(event.getMetaState(),                KeyEvent.META_META_ON | KeyEvent.META_SHIFT_ON)) {            groupNavigationDirection = View.FOCUS_BACKWARD;        }    }    ... ... ...    // 应用 fallback 策略    // 具体实现见PhoneFallbackEventHandler中dispatchKeyEvent()方法    // 主要是对媒体键，音量键，通话键等做处理，如果是这些按键则会停止下面的步骤    if (mFallbackEventHandler.dispatchKeyEvent(event)) {        return FINISH_HANDLED;    }    // 自动追踪焦点    // 该部分是重点    if (event.getAction() == KeyEvent.ACTION_DOWN) {        if (groupNavigationDirection != 0) {            //如果是TAB键则groupNavigationDirection不为0，进行如下操作（这里不做重点解析）            if (performKeyboardGroupNavigation(groupNavigationDirection)) {                return FINISH_HANDLED;            }        } else {            //此处是对我们按键焦点处理的重点            //下面我们进入该方法详细去看一下，详见（2）            if (performFocusNavigation(event)) {                return FINISH_HANDLED;            }        }    }    return FORWARD;}</code></pre><h3 id="（2）performFocusNavigation方法的具体实现（主要用于记录方向）"><a href="#（2）performFocusNavigation方法的具体实现（主要用于记录方向）" class="headerlink" title="（2）performFocusNavigation方法的具体实现（主要用于记录方向）"></a>（2）performFocusNavigation方法的具体实现（主要用于记录方向）</h3><p>我们接下来看一下<code>performFocusNavigation①</code>方法：</p><pre><code>private boolean performFocusNavigation(KeyEvent event) {    //direction用来记录方向的值，用来进行后面的焦点查找    int direction = 0;    switch (event.getKeyCode()) {        case KeyEvent.KEYCODE_DPAD_LEFT:            //根据指定的元状态没有按下修饰符键,则返回true            if (event.hasNoModifiers()) {                direction = View.FOCUS_LEFT;            }            break;        case KeyEvent.KEYCODE_DPAD_RIGHT:            if (event.hasNoModifiers()) {                direction = View.FOCUS_RIGHT;            }            break;        case KeyEvent.KEYCODE_DPAD_UP:            if (event.hasNoModifiers()) {                direction = View.FOCUS_UP;            }            break;        case KeyEvent.KEYCODE_DPAD_DOWN:            if (event.hasNoModifiers()) {                direction = View.FOCUS_DOWN;            }            break;        case KeyEvent.KEYCODE_TAB:            if (event.hasNoModifiers()) {                direction = View.FOCUS_FORWARD;            } else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {                direction = View.FOCUS_BACKWARD;            }            break;    }    //给定了direction（遥控器按键按下的方向），接下来就是焦点寻找    if (direction != 0) {        //找到当前聚焦的View 下面会详细讲解，见（3）        View focused = mView.findFocus();        if (focused != null) {            //如果focused不为空，说明找到了焦点，接着focusSearch会把direction（遥控器按键按下的方向）作为参数，找到特定方向下一个将要获取焦点的view，最后如果该view不为空，那么就让该view获取焦点。            //后面详细介绍focusSearch()具体方法，见（4）            View v = focused.focusSearch(direction);            if (v != null &amp;&amp; v != focused) {                focused.getFocusedRect(mTempRect);                if (mView instanceof ViewGroup) {                    ((ViewGroup) mView).offsetDescendantRectToMyCoords(                            focused, mTempRect);                    ((ViewGroup) mView).offsetRectIntoDescendantCoords(                            v, mTempRect);                }                if (v.requestFocus(direction, mTempRect)) {                    playSoundEffect(SoundEffectConstants                            .getContantForFocusDirection(direction));                    return true;                }            }            // Give the focused view a last chance to handle the dpad key.            if (mView.dispatchUnhandledMove(focused, direction)) {                return true;            }        } else {            if (mView.restoreDefaultFocus()) {                return true;            }        }    }    return false;}</code></pre><h3 id="（3）findFocus方法的具体实现（查找到当前聚焦的view）"><a href="#（3）findFocus方法的具体实现（查找到当前聚焦的view）" class="headerlink" title="（3）findFocus方法的具体实现（查找到当前聚焦的view）"></a>（3）findFocus方法的具体实现（查找到当前聚焦的view）</h3><p>我们来看一下详细看一下<code>findFocus()</code><br><img src="https://user-gold-cdn.xitu.io/2018/6/28/164442cb492e6360?w=1255&amp;h=417&amp;f=png&amp;s=70799" alt><br>我们看到findFocus有viewGroup和view的：<br>其实就是在一层一层往下查找已经获取焦点的子View（一定要先理解视图树）</p><pre><code>//viewGroup焦点判断@Overridepublic View findFocus() {    if (DBG) {        System.out.println(&quot;Find focus in &quot; + this + &quot;: flags=&quot;                + isFocused() + &quot;, child=&quot; + mFocused);    }    if (isFocused()) {        return this;    }    if (mFocused != null) {        return mFocused.findFocus();    }    return null;}</code></pre><pre><code>//view焦点判断public View findFocus() {    return (mPrivateFlags &amp; PFLAG_FOCUSED) != 0 ? this : null;}</code></pre><p>说明：判断view是否获取焦点的isFocused()方法， (mPrivateFlags &amp; PFLAG_FOCUSED) != 0 和view 的findFocus()方法是一致的。</p><pre><code>public boolean isFocused() {    return (mPrivateFlags &amp; PFLAG_FOCUSED) != 0;}</code></pre><p>isFocused()方法的作用是判断view是否已经获取焦点，如果viewGroup已经获取到了焦点，那么返回本身即可，否则通过mFocused的findFocus()方法来找焦点。mFocused其实就是ViewGroup中获取焦点的子view，如果mView不是ViewGourp的话，findFocus其实就是判断本身是否已经获取焦点，如果已经获取焦点了，返回本身。</p><p><strong>此时我们已经找到了当前获得焦点的View，接下来就是说按照给定的方向去寻找下一个即将获得焦点的view</strong></p><h3 id="（4）focusSearch方法的具体实现"><a href="#（4）focusSearch方法的具体实现" class="headerlink" title="（4）focusSearch方法的具体实现"></a>（4）focusSearch方法的具体实现</h3><p>通过View的focusSearch方法找到下一个获取焦点的View，那么到底是如何查找的？往下看：</p><pre><code>//view中public View focusSearch(@FocusRealDirection int direction) {    if (mParent != null) {        return mParent.focusSearch(this, direction);    } else {        return null;    }}</code></pre><p>View并不会直接去找，而是交给它的parent去找。</p><pre><code>//viewGroup中@Overridepublic View focusSearch(View focused, int direction) {    if (isRootNamespace()) {        //判断是否是顶层view，是则执行以下算法        return FocusFinder.getInstance().findNextFocus(this, focused, direction);    } else if (mParent != null) {        return mParent.focusSearch(focused, direction);    }    return null;}</code></pre><p>判断是否为顶层布局（isRootNamespace()方法），若是则执行对应方法，若不是则继续向上寻找，说明会从内到外的一层层进行判断，直到最外层的布局为止。</p><p>最终会调用viewGroup的FocusFinder来找计算下一个获得焦点的view。</p><h3 id="（5）findNextFocus方法的具体实现"><a href="#（5）findNextFocus方法的具体实现" class="headerlink" title="（5）findNextFocus方法的具体实现"></a>（5）findNextFocus方法的具体实现</h3><pre><code>// FocusFinder.javapublic final View findNextFocus(ViewGroup root, View focused, int direction) {    return findNextFocus(root, focused, null, direction);}//root是上面isRootNamespace()为true的ViewGroup//focused是当前焦点视图private View findNextFocus(ViewGroup root, View focused, Rect focusedRect, int direction) {    View next = null;    ViewGroup effectiveRoot = getEffectiveRoot(root, focused);    if (focused != null) {        // 优先从xml或者代码中指定focusid的View中找        next = findNextUserSpecifiedFocus(effectiveRoot, focused, direction);    }    if (next != null) {        return next;    }    ArrayList&lt;View&gt; focusables = mTempList;    try {        focusables.clear();        effectiveRoot.addFocusables(focusables, direction);        if (!focusables.isEmpty()) {            //其次，根据算法去找，原理就是找在方向上最近的View            next = findNextFocus(effectiveRoot, focused, focusedRect, direction, focusables);        }    } finally {        focusables.clear();    }    return next;}</code></pre><blockquote><p>从上面可以看出</p><ul><li>（1）优先找开发者指定的下一个focus的视图 ，就是在xml或者代码中指定NextFocusDirection Id的视图</li><li>（2）其次，根据算法去找，原理就是找在方向上最近的视图</li></ul></blockquote><p>我们这里分开两个方法看<code>findNextUserSpecifiedFocus()</code>和<code>findNextFocus()</code></p><h3 id="（6）findNextUserSpecifiedFocus-从指定focusid的View中找"><a href="#（6）findNextUserSpecifiedFocus-从指定focusid的View中找" class="headerlink" title="（6）findNextUserSpecifiedFocus() 从指定focusid的View中找"></a>（6）findNextUserSpecifiedFocus() 从指定focusid的View中找</h3><pre><code>//FocusFinder.javaprivate View findNextUserSpecifiedFocus(ViewGroup root, View focused, int direction) {    // 寻找用户定义的下一个焦点View    View userSetNextFocus = focused.findUserSetNextFocus(root, direction);    View cycleCheck = userSetNextFocus;    boolean cycleStep = true; // we want the first toggle to yield false    while (userSetNextFocus != null) {        if (userSetNextFocus.isFocusable()                &amp;&amp; userSetNextFocus.getVisibility() == View.VISIBLE                &amp;&amp; (!userSetNextFocus.isInTouchMode()                        || userSetNextFocus.isFocusableInTouchMode())) {            return userSetNextFocus;        }        userSetNextFocus = userSetNextFocus.findUserSetNextFocus(root, direction);        if (cycleStep = !cycleStep) {            cycleCheck = cycleCheck.findUserSetNextFocus(root, direction);            if (cycleCheck == userSetNextFocus) {                // found a cycle, user-specified focus forms a loop and none of the views                // are currently focusable.                break;            }        }    }    return null;}</code></pre><p><code>findNextUserSpecifiedFocus()</code>方法会执行focused(即当前获取焦点的View)的findUserSetNextFocus方法，如果该方法返回的View不为空，且isFocusable = true &amp;&amp; isInTouchMode()=true的话，FocusFinder找到的焦点就是findNextUserSpecifiedFocus()返回的View。</p><pre><code>//View.javafindUserSetNextFocus(View root, @FocusDirection int direction) {    switch (direction) {        case FOCUS_LEFT:            if (mNextFocusLeftId == View.NO_ID) return null;            return findViewInsideOutShouldExist(root, mNextFocusLeftId);        case FOCUS_RIGHT:            if (mNextFocusRightId == View.NO_ID) return null;            return findViewInsideOutShouldExist(root, mNextFocusRightId);        case FOCUS_UP:            if (mNextFocusUpId == View.NO_ID) return null;            return findViewInsideOutShouldExist(root, mNextFocusUpId);        case FOCUS_DOWN:            if (mNextFocusDownId == View.NO_ID) return null;            return findViewInsideOutShouldExist(root, mNextFocusDownId);        case FOCUS_FORWARD:            if (mNextFocusForwardId == View.NO_ID) return null;            return findViewInsideOutShouldExist(root, mNextFocusForwardId);        case FOCUS_BACKWARD: {            if (mID == View.NO_ID) return null;            final int id = mID;            return root.findViewByPredicateInsideOut(this, new Predicate&lt;View&gt;() {                @Override                public boolean test(View t) {                    return t.mNextFocusForwardId == id;                }            });        }    }    return null;}</code></pre><p>findUserSetNextFocus就是通过设置的id去找view，比如：按了“左”方向键，如果设置了mNextFocusLeftId，则会通过findViewInsideOutShouldExist去找这个View。</p><p>来看看findViewInsideOutShouldExist做了什么?</p><pre><code>//View.javaprivate View findViewInsideOutShouldExist(View root, int id) {    if (mMatchIdPredicate == null) {        // 可以理解为一个判定器，如果id匹配则判定成功        mMatchIdPredicate = new MatchIdPredicate();    }    mMatchIdPredicate.mId = id;    View result = root.findViewByPredicateInsideOut(this, mMatchIdPredicate);    ...    return result;}public final View findViewByPredicateInsideOut(View start, Predicate&lt;View&gt; predicate) {    View childToSkip = null;    for (;;) {        // 从当前起始节点开始寻找（ViewGroup是遍历自己的child），寻找id匹配的View        View view = start.findViewByPredicateTraversal(predicate, childToSkip);        if (view != null || start == this) {            return view;        }        ViewParent parent = start.getParent();        if (parent == null || !(parent instanceof View)) {            return null;        }        // 如果如果当前节点没有，则往上一级，从自己的parent中查找，并跳过自己        childToSkip = start;        start = (View) parent;    }}protected View findViewByPredicateTraversal(Predicate&lt;View&gt; predicate, View childToSkip) {    if (predicate.apply(this)) {        return this;    }    return null;}</code></pre><p>// ViewGroup</p><pre><code>@Overrideprotected View findViewByPredicateTraversal(Predicate&lt;View&gt; predicate, View childToSkip) {    if (predicate.apply(this)) {        return this;    }    final View[] where = mChildren;    final int len = mChildrenCount;    for (int i = 0; i &lt; len; i++) {        View v = where[i];        if (v != childToSkip &amp;&amp; (v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == 0) {            v = v.findViewByPredicate(predicate);            if (v != null) {                return v;            }        }    }    return null;}</code></pre><p>可以看到，findViewInsideOutShouldExist这个方法从当前指定视图去寻找指定id的视图。首先从自己开始向下遍历，如果没找到则从自己的parent开始向下遍历，直到找到id匹配的视图为止。</p><h3 id="（7）findNextFocus-根据算法去找"><a href="#（7）findNextFocus-根据算法去找" class="headerlink" title="（7）findNextFocus()根据算法去找"></a>（7）findNextFocus()根据算法去找</h3><p>如果开发者没有指定nextFocusId，则用findNextFocus找指定方向上最近的视图<br>看一下这里的用法：</p><pre><code>//FocusFinder.javaprivate View findNextFocus(ViewGroup root, View focused, Rect focusedRect, int direction) {    View next = null;    ViewGroup effectiveRoot = getEffectiveRoot(root, focused);    if (focused != null) {        next = findNextUserSpecifiedFocus(effectiveRoot, focused, direction);    }    if (next != null) {        return next;    }    ArrayList&lt;View&gt; focusables = mTempList;    try {        focusables.clear();        //找到所有isFocusable的View        effectiveRoot.addFocusables(focusables, direction);        if (!focusables.isEmpty()) {            next = findNextFocus(effectiveRoot, focused, focusedRect, direction, focusables);        }    } finally {        focusables.clear();    }    return next;}</code></pre><p>这里就不对findNextFocus()具体展开了，大概讲一下步骤：</p><blockquote><p><strong>findNextFocus():</strong></p><ul><li>(1)遍历找出所有isFocusable的视图</li><li>(2)将focused视图的坐标系，转换到root的坐标系中，统一坐标，以便进行下一步的计算</li><li>(3)进行一次遍历比较，得到最“近”的视图作为下一个焦点视图</li></ul></blockquote><h2 id="3-3-keyevent分发流程总结"><a href="#3-3-keyevent分发流程总结" class="headerlink" title="3.3 keyevent分发流程总结"></a>3.3 keyevent分发流程总结</h2><blockquote><ul><li>1、ViewRootImpl的processKeyEvent方法获取按键事件</li><li>2、判断ViewGroup的dispatchKeyEvent()方法是否消费了事件是则不往下分发，终止。</li><li>3、判断是否是一些特殊按键如：接听，挂断，音量等</li><li>4、如果没有消费事件，那么焦点就会交给系统来处理</li><li>5、Android底层先会记录按键的方向</li><li>6、DecorView会从顶部一层一层往下调用findFocus方法找到当前获取焦点的View</li><li>7、通过focusSearch从内到外层层寻找下一个焦点view，直到顶层为止，具体算法在FocusFinder</li><li>8、FocusFinder会根据用户设置的id，优先查找，如果没有设置则通过系统算法找到最近的焦点view</li></ul></blockquote><h2 id="3-4-处理焦点的时机"><a href="#3-4-处理焦点的时机" class="headerlink" title="3.4 处理焦点的时机"></a>3.4 处理焦点的时机</h2><p>结合KeyEvent事件的流转，对处理焦点的时机做了如下排序：</p><blockquote><ul><li>1、dispatchKeyEvent</li><li>2、mOnKeyListener.onKey回调</li><li>3、onKeyDown/onKeyUp</li><li>4、focusSearch</li><li>5、指定nextFocusId</li><li>6、系统自动从所有isFocusable的视图中找下一个焦点视图<br>以上任一处都可以指定焦点，一旦使用了就不再往下走。</li></ul></blockquote><p><strong>～～号外～～福利～～号外～～</strong><br><strong>程序员的福音：</strong> “老曾筋骨祛痛贴”，百年祖传配方，专治<em>腰间盘</em>、<em>肩周</em>、<em>颈椎</em>、<em>坐骨神经</em>、<em>腰腿疼痛</em>等，博主亲测效果非常棒，因长期久坐写代码，坐姿不规范导致脖子疼，腰椎疼，用过之后疼痛逐渐缓解，现在已无任何疼痛，用过后让你写代码一身轻松，so easy，妈妈再也不用担心我们写代码了。<br>购买链接： <a href="https://k.weidian.com/tja7GYzB" target="_blank" rel="noopener">https://k.weidian.com/tja7GYzB</a><br><img src="https://img-blog.csdnimg.cn/20190213230334214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zMzMwNDI2MA==" width="40%" alt></p><p><strong>扫码下方二维码，关注公众号“伟大程序猿的诞生“，回复“膏药”领取优惠券</strong><br><strong>扫码关注公众号“伟大程序猿的诞生“，更多干货新鲜文章等着你～</strong><br><img src="http://img.blog.csdn.net/20171218195006434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2l0aHViXzMzMzA0MjYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="40%" alt><br><strong>公众号回复“资料获取”，获取更多干货哦～</strong><br><strong>公众号回复“膏药”，领取优惠券哦～</strong></p><p><strong><em>有问题欢迎联系本人</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> AndroidTV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AndroidTV </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
